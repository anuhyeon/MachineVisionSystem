# -*- coding: utf-8 -*-
"""[MachineVisionSystem]CameraCalibration.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1_jVK1OHpJl8y0QGjk-ozlqXI6IReAknr
"""

# Mount Google Drive
from google.colab import drive
drive.mount('/content/MyDrive')
# Make a new folder for this course
# import os
# path = '/content/MyDrive//MyDrive/MVS/HW_1'
# os.mkdir(path) #  지정된 경로에 새로운 디렉토리를 생성하는 명령

path = '/content/MyDrive//MyDrive/MVS/HW1'

import numpy as np
import cv2 as cv
import glob # glob는 파이썬 표준 라이브러리로, 파일 시스템에서 특정 패턴에 맞는 파일 이름들을 찾기 위해 사용. 주로 와일드카드(*, ?, [])와 함께 파일 경로를 매칭하는 데 사용.
from google.colab.patches import cv_imshow

"""### HEIC 파일 -> JPG 형식으로 변환"""

# !pip install pyheif pillow
# # OpenCV의 이미지 형식 지원 한계: OpenCV의 cv.imread() 함수는 일반적으로 JPEG, PNG, BMP, TIFF 등의 흔한 이미지 형식만을 지원.
# # HEIC 형식은 지원되지 않으므로 이미지를 읽어올 수 없으며, 따라서 img 변수는 None 값을 갖게 됨.

# import pyheif
# from PIL import Image

# # HEIC 이미지 파일 경로
# heic_image_paths = glob.glob('/content/MyDrive/MyDrive/MVS/HW_1/left*.HEIC')
# # 각 HEIC 이미지를 처리
# for heic_image_path in heic_image_paths:
#     # HEIC 이미지 읽기
#     heif_file = pyheif.read(heic_image_path)
#     image = Image.frombytes(
#         heif_file.mode,
#         heif_file.size,
#         heif_file.data,
#         "raw",
#         heif_file.mode,
#         heif_file.stride,
#     )

#     # JPEG 형식으로 저장할 파일 경로 생성
#     output_image_path = heic_image_path.replace('.HEIC', '.jpg').replace('.heic', '.jpg') # 대소문자 처리

#     # JPEG 형식으로 저장
#     image.save(output_image_path, "JPEG")

#     # 변환된 이미지 읽기 및 표시
#     # img = cv.imread(output_image_path)
#     # if img is not None:
#     #     cv_imshow(img)
#     # else:
#     #     print("이미지를 불러올 수 없습니다:", output_image_path)

"""### JPG로 변환하지 않고 HEIC 이미지를 바로 numpy 배열로 변환"""

# # HEIC 이미지 파일 경로 리스트 가져오기
# heic_image_paths = glob.glob('/content/MyDrive/MyDrive/MVS/HW_1/left*.HEIC')

# # 각 HEIC 이미지를 처리
# for heic_image_path in heic_image_paths:
#     # HEIC 이미지 읽기
#     heif_file = pyheif.read(heic_image_path)
#     image = Image.frombytes(
#         heif_file.mode,
#         heif_file.size,
#         heif_file.data,
#         "raw",
#         heif_file.mode,
#         heif_file.stride,
#     )

#     # PIL 이미지를 NumPy 배열로 변환
#     img = np.array(image)

#     # OpenCV는 기본적으로 BGR 순서를 사용하므로, 필요하면 색상 변환
#     if img.shape[2] == 3:  # RGB 이미지인 경우
#         img = cv.cvtColor(img, cv.COLOR_RGB2BGR)
#     elif img.shape[2] == 4:  # RGBA 이미지인 경우
#         img = cv.cvtColor(img, cv.COLOR_RGBA2BGRA)

#     # 이미지 표시
#     cv_imshow(img)

"""### 기본 이미지"""

images = glob.glob('/content/MyDrive/MyDrive/MVS/HW_1/left1.jpg')
print(images[0])
# for img_path in images:
#     img = cv.imread(img_path)
#     cv_imshow(img)
img = cv.imread(images[0])
# print(img)
cv_imshow(img)

"""### 종료 조건 설정"""

# Termination criteria
# 아래는 각각 인자들
# criteria: 코너 검출 및 서브픽셀 정확도를 위한 알고리즘의 종료 조건을 설정하는 변수
# cv.TERM_CRITERIA_EPS: 원하는 정확도에 도달하면 알고리즘을 종료.
# cv.TERM_CRITERIA_MAX_ITER: 지정된 최대 반복 횟수에 도달하면 알고리즘을 종료.
# cv.TERM_CRITERIA_EPS + cv.TERM_CRITERIA_MAX_ITER를 하면 두 조건 중 하나라도 만족하면 알고리즘이 종료 -> 비트 플래그 사용
# 30: 최대 반복 횟수
# 0.001: 원하는 정확도
# 즉, 알고리즘은 최대 30번 반복하거나 정확도가 0.001이하로 떨어질 때 까지 실행된다.
criteria = (cv.TERM_CRITERIA_EPS + cv.TERM_CRITERIA_MAX_ITER, 30, 0.001)
print(cv.TERM_CRITERIA_EPS, cv.TERM_CRITERIA_EPS)
print(criteria)

"""### 객체 포인트 준비
(x,y,z)좌표계를 만드는 과정이라고 보면됨
"""

# Prepare object points, like (0,0,0), (1,0,0), (2,0,0) ....,(6,5,0)
objp = np.zeros((6*8,3), np.float32) # x,y,z ->3개 한점의 좌표의 값을 80개 80 x 3 행렬 생성
# print(objp)
# print(len(objp))
#print(objp[:,:2])
##### 체스보드 패턴의 각 코너에 대한 실제 세계좌표 x,y,z를 생성 #####
objp[:,:2] = np.mgrid[0:6,0:8].T.reshape(-1,2) # 0 ~ 8까지의 x좌표 그리드, 0 ~ 10까지의 y좌표 그리드 생성 , (-1,2)는 배열을 행의 수는 자동으로(-1) 설정하고, 열의 수는 2로 설정하여 2차원 배열로 만듭니다.

# print(objp)
# print(len(objp))

# grid = np.mgrid[0:6, 0:8]
# print(grid)
# print(grid.shape)
# gridT = grid.T
# print(gridT)
# print(gridT.shape)
# gridTreshape = gridT.reshape(-1,2)
# print(gridTreshape)
# print(gridTreshape.shape)

"""### 포인트를 저장할 배열 생성"""

# Arrays to store object points and image points from all the images.
objpoints = []  # 3D points in real world space
imgpoints = []  # 2D points in image plane.
##### objpoints는 세계좌표계이고 imgpoints는 카메라 좌표계임! ####

"""### 이미지 불러오기"""

images = glob.glob('/content/MyDrive/MyDrive/MVS/HW_1/left*.jpg')

print(images)
print(len(images))

for fname in images:
    img = cv.imread(fname)
    gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY) #cv.cvtColor() 함수를 사용하여 이미지를 그레이스케일로 변환
    # Find the chess board corners
    ret, corners = cv.findChessboardCorners(gray, (6,8), None) # gray -> 코너를 찾을 그레이스케일 이미지,(8,10)찾을 코너수,(none)-> 추가적인 플래그 지정x
    # If found, add object points, image points (after refining them)
    if ret == True: # ret: 코너 검출 성공 여부를 나타내는 불리언 값, corners: 검출된 코너들의 좌표 리스트
        objpoints.append(objp)
        corners2 = cv.cornerSubPix(gray,corners, (11,11), (-1,-1), criteria) # 코너위치를 서브픽셀 수준으로 정교화
        imgpoints.append(corners2)
        # Draw and display the corners
        cv.drawChessboardCorners(img, (6,8), corners2, ret)
        # 이미지를 원하는 크기로 리사이즈 (예: 가로 800, 세로 600)
        #$resized_img = cv.resize(img, (600, 800))
        cv_imshow(img)
        # JPEG 형식으로 저장
        image.save('/content/MyDrive/MyDrive/MVS/HW_1/HW_1-2/corners_left*.jpg', "JPEG")


    else:
        print(fname,'is',ret)

print(ret)
print(img.shape, len(img.shape))
print(gray.shape)

print(len(corners))
print(corners)

"""### Camera Calibration"""

# Calibration (camera matrix, distortion coefficients, rotation and translation vectors)
ret, mtx, dist, rvecs, tvecs = cv.calibrateCamera(objpoints, imgpoints, gray.shape[::-1], None, None)
# gray.shape는 (height, width) 형태이므로, [::-1]을 사용하여 (width, height)로 변환함.
# 이유: OpenCV의 함수는 이미지 크기를 (width, height) 순서로 요구한다
print('ret: ', ret)
print('mtx: ', mtx)
print('dist: ', dist)
print('rvecs: ', rvecs)
print('tvecs: ', tvecs)

"""### camera calibration simple AR"""

def draw(img, imgpts):
    imgpts = np.int32(imgpts).reshape(-1,2)
    # draw ground floor in green
    img = cv.drawContours(img, [imgpts[:4]],-1,(0,255,0),-3)
    # draw pillars in blue color
    for i,j in zip(range(4),range(4,8)):
        img = cv.line(img, tuple(imgpts[i]), tuple(imgpts[j]),(255,0,0),3)
    # draw top layer in red color
    img = cv.drawContours(img, [imgpts[4:]],-1,(0,0,255),3)
    return img

axis = np.float32([[0,0,0], [0,3,0], [3,3,0], [3,0,0], [0,0,-3],[0,3,-3],[3,3,-3],[3,0,-3] ])
i=0
for fname in glob.glob('/content/MyDrive/MyDrive/MVS/HW_1/left*.jpg'):
    img = cv.imread(fname)
    gray = cv.cvtColor(img,cv.COLOR_BGR2GRAY)
    ret, corners = cv.findChessboardCorners(gray, (6,8),None)
    if ret == True:
        # project 3D points to image plane
        imgpts, jac = cv.projectPoints(axis, rvecs[i], tvecs[i], mtx, dist)
        i=i+1
        img = draw(img,imgpts)
        cv_imshow(img)
    else:
        print(fname,'is',ret)

# 4,5,6 Failed

# (0, 0, 0)을 기준으로 가로 1, 세로 3, 높이 5인 직육면체 좌표
axis1 = np.float32([[0,0,0], [0,3,0], [1,3,0], [1,0,0], [0,0,-5],[0,3,-5],[1,3,-5],[1,0,-5]])
i=0
for fname in glob.glob('/content/MyDrive/MyDrive/MVS/HW_1/left*.jpg'):
    img = cv.imread(fname)
    gray = cv.cvtColor(img,cv.COLOR_BGR2GRAY)
    ret, corners = cv.findChessboardCorners(gray, (6,8),None)
    if ret == True:
        # project 3D points to image plane
        imgpts, jac = cv.projectPoints(axis1, rvecs[i], tvecs[i], mtx, dist)
        i=i+1
        img = draw(img,imgpts)
        cv_imshow(img)
    else:
        print(fname,'is',ret)

# (2, 2, 0)을 기준으로 가로 1, 세로 3, 높이 5인 직육면체 좌표
axis2 = np.float32([[2,2,0], [2,5,0], [3,5,0], [3,2,0], [2,2,-5],[2,5,-5],[3,5,-5],[3,2,-5]])
i=0
for fname in glob.glob('/content/MyDrive/MyDrive/MVS/HW_1/left*.jpg'):
    img = cv.imread(fname)
    gray = cv.cvtColor(img,cv.COLOR_BGR2GRAY)
    ret, corners = cv.findChessboardCorners(gray, (6,8),None)
    if ret == True:
        # project 3D points to image plane
        imgpts, jac = cv.projectPoints(axis2, rvecs[i], tvecs[i], mtx, dist)
        i=i+1
        img = draw(img,imgpts)
        cv_imshow(img)
    else:
        print(fname,'is',ret)

# (0, 0, 0)을 기준으로 가로 1, 세로 3, 높이 5인 직육면체 좌표
axis1 = np.float32([[0,0,0], [0,3,0], [1,3,0], [1,0,0], [0,0,-5],[0,3,-5],[1,3,-5],[1,0,-5]])

# (2, 2, 0)을 기준으로 가로 1, 세로 3, 높이 5인 직육면체 좌표
axis2 = np.float32([[2,2,0], [2,5,0], [3,5,0], [3,2,0], [2,2,-5],[2,5,-5],[3,5,-5],[3,2,-5]])

# 투영을 위한 코드
for i, fname in enumerate(glob.glob('/content/MyDrive/MyDrive/MVS/HW_1/left*.jpg')):
    img = cv.imread(fname)
    gray = cv.cvtColor(img, cv.COLOR_BGR2GRAY)
    ret, corners = cv.findChessboardCorners(gray, (6,8), None)

    if ret == True:
        # 코너 위치 세밀 조정
        #corners2 = cv.cornerSubPix(gray, corners, (11,11), (-1,-1), criteria)

        # 캘리브레이션 매트릭스를 이용하여 3D 포인트를 이미지 평면에 투영
        imgpts1, _ = cv.projectPoints(axis1, rvecs[i], tvecs[i], mtx, dist)
        imgpts2, _ = cv.projectPoints(axis2, rvecs[i], tvecs[i], mtx, dist)

        # 투영된 직육면체 그리기
        img = draw(img, imgpts1)
        img = draw(img, imgpts2)

        # 이미지 출력
        cv_imshow(img)
    else:
        print(fname,'is',ret)

